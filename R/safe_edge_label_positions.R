#' @title Adjust Edge Label Positions to
#' Avoid Overlapping Labels
#'
#' @description Move the edge labels
#' away from path intersections.
#'
#' @details
#' (TODO)
#'
#' @return
#' A named numeric vector of edge
#' positions to be used by
#' [set_edge_label_position()].
#'
#' @param object It can be the output of
#' [lavaan::sem()] or
#' [lavaan::lavaan()], or a
#' `lavaan`-class object. The model must
#' have a `beta` matrix of the
#' structural path. It can also be a
#' `qgraph` object generated by
#' [semPlot::semPaths()].
#'
#' @param layout A layout matrix.
#' Required if `object` is a
#' `lavaan`-class object. Ignored if
#' `object` is a `qgraph` object.
#'
#' @param default_pos
#'
#' @seealso [set_edge_label_position()]
#' on setting the positions of edge
#' labels.
#'
#' @examples
#'
#' # TODO: Revise the example.
#'
#' library(lavaan)
#' library(semPlot)
#'
#' # Create a dummy dataset
#' mod_pa <-
#' "
#' m11 ~ c1 + x1
#' m21 ~ c2 + m11
#' m2 ~ m11 + c3
#' m22 ~ m11 + c3
#' y ~ m2 + m21 + m22 + x1
#' "
#' fit <- lavaan::sem(
#'           mod_pa,
#'           do.fit = FALSE
#'         )
#' dat <- simulateData(
#'           parameterTable(fit),
#'           sample.nobs = 500,
#'           seed = 1234
#'         )
#' fit <- lavaan::sem(
#'           mod_pa,
#'           dat
#'         )
#'
#' # Set the layout
#' m <- auto_layout_mediation(
#'         fit,
#'         exclude = c("c1", "c2", "c3")
#'       )
#' pm <- semPlotModel(fit) |> drop_nodes(c("c1", "c2", "c3"))
#' semPaths(
#'           pm,
#'           whatLabels = "est",
#'           layout = m
#'         )
#'
#' # v_pos = "lower"
#' m <- auto_layout_mediation(
#'         fit,
#'         exclude = c("c1", "c2", "c3"),
#'         v_pos = "lower"
#'       )
#' pm <- semPlotModel(fit) |> drop_nodes(c("c1", "c2", "c3"))
#' p0 <- semPaths(
#'           pm,
#'           whatLabels = "est",
#'           layout = m
#'         )
#'
#' # v_pos = "upper"
#' m <- auto_layout_mediation(
#'         fit,
#'         exclude = c("c1", "c2", "c3"),
#'         v_pos = "upper"
#'       )
#' pm <- semPlotModel(fit) |> drop_nodes(c("c1", "c2", "c3"))
#' p0 <- semPaths(
#'           pm,
#'           whatLabels = "est",
#'           layout = m
#'         )
#'
#' @noRd
# Input:
# - A matrix of intersections
# Output:
# - A named vector of new positions
safe_edge_label_positions <- function(
                              object,
                              layout = NULL,
                              default_pos = .5,
                              tolerance = .05
                            ) {

  object_type <- NA
  if (inherits(object, "lavaan")) {
    object_type <- "lavaan"
    if (lavaan::lavTech(object, "ngroups") != 1) {
      stop("Multigroup models not supported.")
    }
    beta0 <- lavaan::lavInspect(
                object,
                what = "free"
              )$beta
    if (is.null(beta0)) {
      stop("The model has no structural paths. Is it a CFA model?")
    }
    mxy <- layout_to_layoutxy(layout)
  } else if (inherits(object, "qgraph")) {
    object_type <- "qgraph"
    beta0 <- qgraph_to_beta(object)
    mxy <- qgraph_to_layoutxy(object)
  } else {
    stop("object is not a supported type.")
  }

  vnames <- rownames(mxy)
  beta1 <- beta0[vnames, vnames, drop = FALSE]

  m_paths <- all_paths(
                beta = beta1,
                m = mxy
              )
  m_intersect <- intersect_matrix(m_paths)
  m0 <- split(m_intersect,
              seq_len(nrow(m_intersect)))
  names(m0) <- rownames(m_intersect)

  if (object_type == "lavaan") {
    default_pos1 <- rep(default_pos, length(m0))
  } else if (object_type == "qgraph") {
    e_pos <- qgraph_to_edge_label_positions(object)
    default_pos1 <- sapply(
                      m_paths,
                      function(x) {
                        e_pos[x$to, x$from]
                      })
    names(default_pos1) <- names(m0)
  }

  out <- mapply(
            safe_edge_label_position_i,
            x = m0,
            default_pos = default_pos1,
            MoreArgs = list(
                          tolerance = tolerance
                        ),
            SIMPLIFY = TRUE,
            USE.NAMES = TRUE)

  out <- out[out != default_pos]
  out
}

#' @noRd
safe_edge_label_position_i <- function(
                      x,
                      default_pos = .5,
                      tolerance = .1
                    ) {
  if (all(is.na(x))) {
    return(default_pos)
  }
  x <- x[!is.na(x)]
  x <- sort(x)
  if (min(abs(default_pos - x)) > tolerance) {
    return(default_pos)
  }
  x0 <- c(tolerance, x, 1 - tolerance)
  x1 <- diff(x0)
  i <- which.max(x1)
  out <- mean(x0[c(i, i + 1)])
  out
}
